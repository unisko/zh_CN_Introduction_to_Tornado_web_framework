#第四章

**数据库**

**Database**

本章中，将会展示一些用到数据库的Tornado web应用新例子。将以一个简单的RESTful API示例开始，然后继续来创建一个在之前的“模板实践：Burt‘s Books”中引入的Burt's Books网站的完整功能版本。

本章中的示例使用了MongoDB作为数据库，以及pymongo作为接连到MongoDB的Python驱动器。当然，有众多数据库都可以以用在Tornado web应用中，比如Redis、CouchDB及MySQL等几个都是相当著名的选项，同时Tornado本身就带有一个包装MySQL请求的库（Tornado itself ships with a library for wrapping MySQL requests）。选择使用MongoDB是因为其简单性及方便性：安装容易又与Python代码集成很好。其无模式本性令到不必为其预先定义数据结构, 而这对原型设计是极好的（Its schemaless nature makes it unnecessary to predefine your data structures, which is great for prototyping）。

本章中假定在运行示例代码的机器上有一个MongoDB的安装运行着，但将代码修改为使用远端服务器上运行的MongoDB是很容易的。如不想在自己的机器上安装MongoDB, 或者所用系统上没有MongoDB的二进制程序，那么网络上有着一些托管的MongoDB服务（a number of hosted MongoDB services）可以用于替代使用。建议使用[MongoHQ](http://www.mongohq.com/)。在前几个示例中，将假设在本地机器上有MongoDB运行，不过也是很容易将代码修改为运行于远端服务器的（包括MongoHQ）。

同时假定你有一些数据库方面的经验，但并不一定是特定于MongoDB的任何经验。当然，这里只能涉及到MongoDB皮毛的一些东西；一定要读读MongoDB文档([http://www.mongodb.org/display/DOCS/Home](http://www.mongodb.org/display/DOCS/Home)), 获取更多信息。那么就开始吧！

> **译者注：**由于机器上没有MongoDB, 译者对数据库的选用上，对于小数据量，倾向于使用SQLite这样的轻量基于磁盘的数据库C库，其无需单独服务器进程。**SQLite使用非标准的SQL查询语言变体。用于内部数据存储**。在构建应用原型时用SQLite, 然后将代码移植到PostgreSQL这样的更大数据库上。


##使用sqlite3模块对SQLite的基本操作

**Basic SQLite Operations with sqlite3**

在可以写出一个使用SQLite web应用之前，需要学习如何从Python用到SQLite。本小节将学到如何使用sqlite3模块，连接到SQLite数据库，接着就是使用sqlite3来创建、获取及更新一个SQLite数据库中的数据了。

sqlite3模块是由Gerhard Haring编写的，提供了一个符合[PEP 249](http://www.python.org/dev/peps/pep-0249)中描述的DB-API 2.0规范的SQL接口。

###建立一个连接

**Establishing a Connection**

首先，需要导入sqlite3库，并建立一个到某SQLite数据库的连接。

```python
>>> import sqlite3
>>> conn = sqlite3.connect('example.db')
```

一旦有了一个连接，就可以创建一个焦点对象（a Cursor object），而通过调用焦点对象的`execute()`方法，就可以执行SQL命令了。

```python
>>> import sqlite3
>>> conn = sqlite3.connect('example.db')
>>> c = conn.cursor()
>>> sqlstr = '''DROP TABLE IF EXISTS stocks'''
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> sqlstr = '''CREATE TABLE stocks (date text, trans text, symbol text, qty real, price real)'''
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> sqlstr = "INSERT INTO stocks VALUES ('2006-01-05', 'BUY', 'RHAT', 100, 35.14)"
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> conn.commit()
>>> symbol = 'RHAT'
>>> sqlstr = "SELECT * FROM stocks WHERE symbol = '%s'" % symbol
>>> c.execute(sqlstr)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> print c.fetchone()
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
>>> t = ('RHAT', )
>>> sqlstr = "SELECT * FROM stocks WHERE symbol = ?"
>>> c.execute(sqlstr, t)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> print c.fetchone()
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
>>> purchases = [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),]
>>> purchases.append(('2006-04-05', 'BUY', 'MSFT', 1000, 72.00))
>>> purchases.append(('2006-04-06', 'SELL', 'IBM', 500, 53.00))
>>> sqlstr = "INSERT INTO stocks VALUES (?, ?, ?, ?, ?)"
>>> c.executemany(sqlstr, purchases)
<sqlite3.Cursor object at 0x7fb5b01230a0>
>>> conn.commit()
>>> sqlstr = "SELECT * FROM stocks ORDER BY price"
>>> for row in c.execute(sqlstr):
...     print row
...
(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.14)
(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)
(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)
(u'2006-04-05', u'BUY', u'MSFT', 1000.0, 72.0)
>>>
```

###SQLite表记录与JSON

**SQLite Table Records and JSON**

在开发web应用时，经常要将一个Python字典变量序列化为一个JSON对象（比如，作为对一次AJAX请求的响应）。而使用sqlite3从SQLite中取得的记录是简单的元组（tuple），在将其转换成字典后，就假定可以通过将其传递给`json`模块的`dumps`函数，而简单地转换成JSON对象。

```python
>>> import sqlite3
>>> import json
>>> conn = sqlite3.connect('example.db')
>>> cur = conn.cursor()
>>> sqlstr = "SELECT * FROM stocks ORDER BY price"
>>> names = ('date', 'trans', 'symbol', 'qty', 'price')
>>> results = list()
>>> for row in cur.execute(sqlstr):
...     result = dict()
...     for i  in range(5):
...         result[names[i]] = row[i]
...
...     results.append(result)
...
>>> for res in results:
...     json.dumps(res)
...
'{"date": "2006-01-05", "symbol": "RHAT", "trans": "BUY", "price": 35.14, "qty": 100.0}'
'{"date": "2006-03-28", "symbol": "IBM", "trans": "BUY", "price": 45.0, "qty": 1000.0}'
'{"date": "2006-04-06", "symbol": "IBM", "trans": "SELL", "price": 53.0, "qty": 500.0}'
'{"date": "2006-04-05", "symbol": "MSFT", "trans": "BUY", "price": 72.0, "qty": 1000.0}'
```

##一个简单的持久化web服务

**A Simple Persistent Web Service**

现在我们已经掌握了编写一个访问SQLite数据库中数据的足够知识。首先，将要写出一个仅从SQLite中读取数据的web服务。接着要写一个读和写数据的。

###一个只读的字典

**A Read-Only Dictionary**

将要构建的这个应用是一个简单的基于web的字典。只能发出每个特定单词的请求，然后回来的是那个单词的定义。下面就是一个典型的交互看起来的样子。

```bash
$ curl http://localhost:8000/oarlock
{definition: "A device attached to a rowboat to hold the oars in place", "word": "oarlock"}
```

此web服务将从一个SQLite数据库中拉取数据。肯定的是，将会通过数据表的`word`字段来查找记录。在实际研究该web应用的源码前，先通过Python交互式解释器将一些单词加入到数据库中吧。

```python
import sqlite3
conn = sqlite3.connect('example.db')
cur = conn.cursor()
sqlstr = "DROP TABLE IF EXISTS dict"
cur.execute(sqlstr)
sqlstr = "CREATE TABLE dict (word text, definition text)"
cur.execute(sqlstr)
words = [('oarlock', 'A device attatched to a rowboat to hold the oars in place'),]
words.append(('seminomadic', 'Only partially nomadic'))
words.append(('perturb', 'Bother, unsettle, modify'))
sqlstr = "INSERT INTO dict VALUES (?, ?)"
cur.executemany(sqlstr, words)
```

示例4-1中是字典web服务的源码，该程式将对上面加入的单词进行查找，并以单词定义响应查询请求。

*例4-1, 字典web服务：definition_readonly.py*

```python
#!/usr/bin/env python2.7
# -*-coding: utf-8**

import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
import os.path

import sqlite3

from tornado.options import define, options
define("port", default=8000, help=u"在给定的端口上运行", type=int)

BASE_DIR = os.path.dirname(os.path.abspath(__file__))


class Application(tornado.web.Application):
    def __init__(self):
        handlers = [(r"/(\w+)", WordHandler)]
        tornado.web.Application.__init__(self, handlers, debug=True)


class WordHandler(tornado.web.RequestHandler):
    def get(self, word):
        db_path = os.path.join(BASE_DIR, "example.db")
        conn = sqlite3.connect(db_path)
        cur = conn.cursor()
        sql = "SELECT definition FROM dict WHERE word = '%s'" % word
        ret = dict()
        cur.execute(sql)
        res = cur.fetchone()
        if res:
            ret['definition'] = res[0]
            self.write(ret)
        else:
            self.set_status(404)
            self.write({"error": "word not found"})
        conn.close()

if __name__ == "__main__":
    tornado.options.parse_command_line()
    http_server = tornado.httpserver.HTTPServer(Application())
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```

